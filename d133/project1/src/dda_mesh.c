/*----------------------------------------------------------------------------*/
/**
* @pkg dda_mesh
*/
/**
* Mesh handle.
*
* (C) DDA team, Kiev, Ukraine 2012.<br>
* started 25.12.2012  9:12:03<br>
* @pkgdoc dda_mesh
* @author oleg
* @version 0.01 
*/
/*----------------------------------------------------------------------------*/
#include "dda_mesh.h"
/*----------------------------------------------------------------------------*/
static int m_mesh_index = INVALID_MESH_INDEX;
/*----------------------------------------------------------------------------*/
/*
ASTN
325/400 (45/38)=0
270/325 (53/45)=1
230/270 (63/53)=2
200/230 (75/63)=3
170/200 (90/75)=4
140/170 (106/80)=5
120/140 (125/106)=6
100/120 (150/125)=7
80/100 (180/150)=8
70/80 (212/180)=9
60/70 (250/212)=10
50/60 (300/250)=11
45/50 (355/300)=12
40/45 (425/355)=13
35/40 (500/425)=14
30/35 (595/500)=15
25/30 (710/595)=16
20/25 (850/710)=17
18/20 (1000/850)=18
16/18 (1180/1000)=19
14/16 (1400/1180)=20
*/
/*----------------------------------------------------------------------------*/
const mesh_t astm[] =
{
    {"45/38", 45, 38}
  , {"53/45", 53, 45}
  , {"63/53", 63, 53}
  , {"75/63", 75, 63}
  , {"90/75", 90, 75}
  , {"106/80", 106, 80}
  , {"125/106", 125, 106}
  , {"150/125", 150, 125}
  , {"180/150", 180, 150}
  , {"212/180", 212, 180}
  , {"250/212", 250, 212}
  , {"300/250", 300, 250}
  , {"355/300", 355, 300}
  , {"425/355", 425, 355}
  , {"500/425", 500, 425}
  , {"595/500", 595, 500}
  , {"710/595", 710, 595}
  , {"850/710", 850, 710}
  , {"1000/850", 1000, 850}
  , {"1180/1000", 1180, 1000}
  , {"1400/1180", 1400, 1180}
};
/*----------------------------------------------------------------------------*/
static decimal32_t m_size_deviation[] =
{
  /*325/400 (45/38)=0*/   {19, 2}, //0.19
  /*270/325 (53/45)=1*/   {20, 2}, //0.20
  /*230/270 (63/53)=2*/   {21, 2}, //0.21
  /*200/230 (75/63)=3*/   {22, 2}, //0.22
  /*170/200 (90/75)=4*/   {23, 2}, //0.23
  /*140/170 (106/80)=5*/  {24, 2}, //0.24
  /*120/140 (125/106)=6*/ {25, 2}, //0.25
  /*100/120 (150/125)=7*/ {25, 2}, //0.25
  /*80/100 (180/150)=8*/  {25, 2}, //0.25
  /*70/80 (212/180)=9*/   {25, 2}, //0.25
  /*60/70 (250/212)=10*/  {25, 2}, //0.25
  /*50/60 (300/250)=11*/  {25, 2}, //0.25
  /*45/50 (355/300)=12*/  {25, 2}, //0.25
  /*40/45 (425/355)=13*/  {25, 2}, //0.25
  /*35/40 (500/425)=14*/  {25, 2}, //0.25
  /*30/35 (595/500)=15*/  {25, 2}, //0.25
  /*25/30 (710/595)=16*/  {25, 2}, //0.25
  /*20/25 (850/710)=17*/  {25, 2}, //0.25
  /*18/20 (1000/850)=18*/ {25, 2}, //0.25
  /*16/18 (1180/1000)=19*/{25, 2}, //0.25
  /*14/16 (1400/1180)=20*/{25, 2}  //0.25
};

static MENU_ITEM items[sizeof(astm)/sizeof(astm[0])];
static int menu_handler(void *data, event_t evt, int param1, void *param2);
/*----------------------------------------------------------------------------*/

int mesh_index()
{
  return m_mesh_index;
}
/*----------------------------------------------------------------------------*/
void set_mesh_index(int index)
{
  if(index < 0 || index >= (int) (sizeof(astm)/sizeof(astm[0])))
    m_mesh_index = INVALID_MESH_INDEX;
  else
    m_mesh_index = index;
}
/*----------------------------------------------------------------------------*/
const mesh_t* mesh()
{
  if(m_mesh_index >= 0 && m_mesh_index < (int) (sizeof(astm)/sizeof(astm[0])))
    return &astm[m_mesh_index];
  return 0;
}
/*----------------------------------------------------------------------------*/
const decimal32_t* relative_size_deviation()
{
  if(m_mesh_index >= 0 && m_mesh_index < (int) (sizeof(m_size_deviation)/sizeof(m_size_deviation[0])))
    return &m_size_deviation[m_mesh_index];
  return 0;
}
/*----------------------------------------------------------------------------*/
void init_mesh_menu(MENU_ITEM *root)
{
  unsigned i;
  for(i = 0; i < sizeof(astm)/sizeof(astm[0]); i++)
  {
    menu_item_init(astm[i].caption, menu_handler, &items[i]);
    menu_item_add_child(root, &items[i]);
  }
}
/*----------------------------------------------------------------------------*/
static int menu_handler(void *data, event_t evt, int param1, void *param2)
{
  (void) data; //Prevent unused warning
  (void) param1;
  (void) param2;
  switch(evt)
  {
  case MENU_EVENT:
    set_mesh_index(param1 - 1);
    return MENU_OK;

  default:
    break;
  }
  return 0;
}
/*----------------------------------------------------------------------------*/
